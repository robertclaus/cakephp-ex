<!DOCTYPE html>
<!-- saved from url=(0049)http://inspirit.github.io/jsfeat/sample_yape.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="A JavaScript Computer Vision Library">
        <meta name="author" content="Eugene Zatepyakin">
        <title>JSFeat - JavaScript Computer Vision Library.</title>

        <link rel="stylesheet" href="./JSFeat - JavaScript Computer Vision Library._files/css">
        <link rel="stylesheet" href="./JSFeat - JavaScript Computer Vision Library._files/bootstrap.css">
        <link rel="stylesheet" href="./JSFeat - JavaScript Computer Vision Library._files/jsfeat.css">

    </head>
    <body>
            <video style="display:none" id="webcam" width="640" height="480" autoplay></video>
            <div style=" width:640px;height:480px;margin: 10px auto;">
                <canvas id="canvas" width="640" height="480"></canvas>
                <div id="no_rtc" class="alert alert-error" style="display:none;"></div>
                <div id="log" class="alert alert-info"><strong>FPS: 16.78</strong><br>grayscale: 1ms<br>box blur: 4ms<br>yape: 8ms</div>
            </div>

        <script type="text/javascript" src="./JSFeat - JavaScript Computer Vision Library._files/jquery.min.js"></script>
        <script type="text/javascript" src="./JSFeat - JavaScript Computer Vision Library._files/jsfeat-min.js"></script>
        <script type="text/javascript" src="./JSFeat - JavaScript Computer Vision Library._files/compatibility.js"></script>
        <script type="text/javascript" src="./JSFeat - JavaScript Computer Vision Library._files/profiler.js"></script>
        <script type="text/javascript" src="./JSFeat - JavaScript Computer Vision Library._files/dat.gui.min.js"></script>
        <script type="text/javascript">
var video;
        $(window).load(function() {
            "use strict";

            // lets do some fun
            video = $('#webcam')[0];//document.getElementById('webcam');
            var canvas = document.getElementById('canvas');
            try {
			//console.log("In try")
                var attempts = 0;
                var readyListener = function(event) {
                    findVideoSize();
                };
                var findVideoSize = function() {
                    if(video.videoWidth > 0 && video.videoHeight > 0) {
                        video.removeEventListener('loadeddata', readyListener);
                        onDimensionsReady(video.videoWidth, video.videoHeight);
                    } else {
                        if(attempts < 10) {
                            attempts++;
                            setTimeout(findVideoSize, 200);
                        } else {
                            onDimensionsReady(640, 480);
                        }
                    }
                };
                var onDimensionsReady = function(width, height) {
                    demo_app(width, height);
                    compatibility.requestAnimationFrame(tick);
                };

                video.addEventListener('loadeddata', readyListener);

                compatibility.getUserMedia({video: true}, function(stream) {
                    try {
                        video.src = compatibility.URL.createObjectURL(stream);
                    } catch (error) {
                        video.src = stream;
                    }
                    setTimeout(function() {
                            video.play();
                        }, 500);
                }, function (error) {
                    $('#canvas').hide();
                    $('#log').hide();
                    $('#no_rtc').html('<h4>WebRTC not available.</h4>');
//console.log(error);
                    $('#no_rtc').show();
                });
            } catch (error) {
                $('#canvas').hide();
                $('#log').hide();
                $('#no_rtc').html('<h4>Something goes wrong...</h4>');
			//console.log(error);
                $('#no_rtc').show();
            }

            var stat = new profiler();

            var ctx,canvasWidth,canvasHeight,ctx2;
            var img_u8, corners;

            var gui, options;
            var curr_img_pyr, prev_img_pyr, point_count, point_status, prev_xy, curr_xy;


            function demo_app(videoWidth, videoHeight) {
                canvasWidth  = canvas.width;
                canvasHeight = canvas.height;
                ctx = canvas.getContext('2d');
			ctx2 = new jsfeat.matrix_t(640, 480, jsfeat.U8_t);

                ctx.fillStyle = "rgb(0,255,0)";
                ctx.strokeStyle = "rgb(0,255,0)";

                img_u8 = new jsfeat.matrix_t(640, 480, jsfeat.U8_t | jsfeat.C1_t);

                corners = [];
                var i = 640*480;
                while(--i >= 0) {
                    corners[i] = new jsfeat.keypoint_t(0,0,0,0);
                }

                // YAPE detector needs init first
                jsfeat.yape.init(canvasWidth, canvasHeight, 5, 1);

                stat.add("grayscale");
                stat.add("box blur");
                stat.add("yape");
                stat.add("render");


                curr_img_pyr = new jsfeat.pyramid_t(3);
                prev_img_pyr = new jsfeat.pyramid_t(3);
                curr_img_pyr.allocate(640, 480, jsfeat.U8_t | jsfeat.C1_t);
                prev_img_pyr.allocate(640, 480, jsfeat.U8_t | jsfeat.C1_t);

                point_count = 0;
                point_status = new Uint8Array(100);
                prev_xy = new Float32Array(100 * 2);
                curr_xy = new Float32Array(100 * 2);

                options = new demo_opt();
                gui = new dat.GUI();

                gui.add(options, 'win_size', 7, 30).step(1);
                gui.add(options, 'max_iterations', 3, 30).step(1);
                gui.add(options, 'epsilon', 0.001, 0.1).step(0.0025);
                gui.add(options, 'min_eigen', 0.001, 0.01).step(0.0025);

                stat.add("grayscale");
                stat.add("build image pyramid");
                stat.add("optical flow lk");



            }
		



            var demo_opt = function () {
                this.win_size = 20;
                this.max_iterations = 30;
                this.epsilon = 0.01;
                this.min_eigen = 0.001;
            }

            //Gaussian blur scale
            var scale = 5;

            //**** Tracking Camera Position *****
            //Current camera position estimate.
            var c = { x: 0, y: 0, z: 0.7 };
            //Threshold for recalculating distance between camera and new position.
            var distanceThreshold = .00001;
            //Current total summed distance^2 from KnownPoints -> PixelPoints line to Camera Point
            var oldDistance;
            //Camera property constants.  Indicate pixel/meter conversions (convx and convy) and the camera focal distance (constz).

            //How often to output the current camera position.
            var timesbetweenposition = 60;
            //How many cycles have not displayed the current camera position in a row.
            var timebetweenposition = 1;
            //Array of the points we assume to know the real world position of.
            var knownpoints = new Array();
            //Sets up known points once started==true.  Real world meter coordinates.
            function initializeKnownPoints()
            {
                console.log("Setting knownpoints");
                knownpoints[0] = { x: -.03, y: .04, z: 0 };
                knownpoints[1] = { x: .03, y: .04, z: 0 };
                knownpoints[2] = { x: 0, y: 0, z: 0 };
            }
            //How far to try to move the camera in each step to see if error distance improves.
            var stepSize = .01;
            //Gets added to the camera position error each frame to encourage reoptimizing the position. (esp. as the camera moves)
            var cameraPositionDecay = .0001;



            //*****Adding new tracked points from features*****

            //How many points we have added.
            var startedpointcount = 0;
            //How many points we need to start autodetecting points.
            var startedpointcountneeded = 3;
            //Whether we are currently detecting additional points.
            var started = false;

            //Features are newly detected points of interest that are not being tracked yet.
            //Points are manually placed, or already detected features that are being tracked.

            //Currently we do point-point, then point-feature, then feature-feature
            //So this pruning can take multiple frames to occur fully.

            //Minimum distance from new feature to old point (feature will be ignored)
            var featuretopoint = 10;
            //Minimum distance from old point to old point (newest will be pruned)
            var pointtopoint = 10;
            //Minimum distance from feature to feature
            var featuretofeature = 10;
            //Maximum points to add.
            var maxpoints = 200;
            //How many frames a pixel must contain a feature before being considered for tracking.
            var featurepersistancetocount = 2;


            var count;
            function tick() {

                compatibility.requestAnimationFrame(tick);
                stat.new_frame();
                if (video.readyState === video.HAVE_ENOUGH_DATA) {

                    ctx.drawImage(video, 0, 0, 640, 480);
                    var imageData = ctx.getImageData(0, 0, 640, 480);
                    
                    if (started == true) {
                        stat.start("grayscale");
                        jsfeat.imgproc.grayscale(imageData.data, 640, 480, img_u8);
                        stat.stop("grayscale");

                        stat.start("box blur");
                        jsfeat.imgproc.box_blur_gray(img_u8, img_u8, scale, 0);
                        stat.stop("box blur");

                        stat.start("yape");

                        if (count > 1000) {
                            scale++;
                        }
                        if (count < 800) {
                            if (scale > 3) {
                                scale--;
                            }

                        }

                        count = jsfeat.yape.detect(img_u8, corners, 1);

                        //console.log("scale: " + scale);

                        var data_u32 = new Uint32Array(imageData.data.buffer);


                        stat.stop("yape");
                    }
                   // console.log(count);

                    //curr_img_pyr = new jsfeat.pyramid_t(3);
                    //prev_img_pyr = new jsfeat.pyramid_t(3);
                    //curr_img_pyr.allocate(640, 480, jsfeat.U8_t | jsfeat.C1_t);
                    //prev_img_pyr.allocate(640, 480, jsfeat.U8_t | jsfeat.C1_t);

                    //point_count = 0;
                    //point_status = new Uint8Array(100);
                    //prev_xy = new Float32Array(100 * 2);
                    //curr_xy = new Float32Array(100 * 2);

                    //options = new demo_opt();
                    //gui = new dat.GUI();

                    //gui.add(options, 'win_size', 7, 30).step(1);
                    //gui.add(options, 'max_iterations', 3, 30).step(1);
                    //gui.add(options, 'epsilon', 0.001, 0.1).step(0.0025);
                    //gui.add(options, 'min_eigen', 0.001, 0.01).step(0.0025);

                    //stat.add("grayscale");
                    //stat.add("build image pyramid");
                    //stat.add("optical flow lk");





                    //stat.start("render");
                    // render result back to canvas

                    
                    //ctx.drawImage(video, 0, 0, 640, 480);
                    //var imageData = ctx.getImageData(0, 0, 640, 480);

                    // swap flow data
                    var _pt_xy = prev_xy;
                    prev_xy = curr_xy;
                    curr_xy = _pt_xy;
                    var _pyr = prev_img_pyr;
                    prev_img_pyr = curr_img_pyr;
                    curr_img_pyr = _pyr;

                    stat.start("grayscale");
                    jsfeat.imgproc.grayscale(imageData.data, 640, 480, curr_img_pyr.data[0]);
                    stat.stop("grayscale");

                    stat.start("build image pyramid");
                    curr_img_pyr.build(curr_img_pyr.data[0], true);
                    stat.stop("build image pyramid");
                    stat.start("optical flow lk");
                    jsfeat.optical_flow_lk.track(prev_img_pyr, curr_img_pyr, prev_xy, curr_xy, point_count, options.win_size | 0, options.max_iterations | 0, point_status, options.epsilon, options.min_eigen);
                    stat.stop("optical flow lk");
                    //Must come before pruning so indexes are the same.
                    calcmotion();


                    //console.log("features found: " + count);
                    prune_oflow_points(ctx);
                    render_corners(data_u32, 640); //Must come after prune_oflow_points
                    findPosition();
                    //console.log("viable features: " + count);
                    //ctx.putImageData(imageData, 0, 0);

                    //ctx.drawImage(video, 0, 0, 640, 480);
                    //var imageData = ctx.getImageData(0, 0, 640, 480);

                    
                   // stat.stop("render");
                    //ctx2 = ctx2 - 1;
                    $('#log').html(stat.log() + '<br/>click to add tracking points: ' + point_count);
                    $('#log').html(/*stat.log() + */ oldDistance + '<br/>X: ' + c.x + '<br/>Y: ' + c.y + '<br/>Z: ' + c.z);
                }
            }

            function calcmotion()
            {
                var xtot = 0;
                var ytot = 0;
                var countpoints = 0;
                var n = point_count;
                var i = 0;
                //console.log("points: " + point_count);
                for (; i < n; ++i) {
                    if (point_status[i] == 1) {
                        xtot = xtot + curr_xy[i << 1] - prev_xy[i << 1];
                        ytot = ytot + curr_xy[(i << 1)+1] - prev_xy[(i << 1)+1];
                        countpoints++;
                    }
                }
               // console.log("Motion: "+Math.round(xtot / countpoints)+", "+Math.round(ytot/countpoints));
            }

            function on_canvas_click(e) {
                var coords = canvas.relMouseCoords(e);
                addpoint(coords.x, coords.y);
            }
            canvas.addEventListener('click', on_canvas_click, false);

            function addpoint(x, y)
            {
                if (x > 0 & y > 0 & x < canvasWidth & y < canvasHeight) {
                    curr_xy[point_count << 1] = x;
                    curr_xy[(point_count << 1) + 1] = y;
                    point_count++;
                    startedpointcount++;

                    if (startedpointcount == startedpointcountneeded)
                    {
                        initializeKnownPoints();
                        started = true;
                    }
                }
                //console.log(point_count);
            }


            function findPosition()
            {
                 nextDirection();
                 tryDirection();
                 if (timebetweenposition < timesbetweenposition) {
                     timebetweenposition++;
                 }
                 else {
                     console.log("Distance: " + oldDistance + "       X:" + c.x + "     Y:" + c.y + "      Z:" + c.z);
                     timebetweenposition = 1;
                 }
            }

            function tryDirection ()
            {
                c.x += dx;
                c.y += dy;
                c.z += dz;
                var newDistance = distance2camera(c);
                if (newDistance != -1) {
                    if (newDistance > oldDistance) {
                        c.x -= dx;
                        c.y -= dy;
                        c.z -= dz;
                        //Encourage exploration.
                        oldDistance += cameraPositionDecay;//.01;
                    }
                    else {
                        oldDistance = newDistance;
                    }
                }
            }


            var mode = 1;
            var dx = 0;
            var dy = 0;
            var dz = 0;
            function nextDirection()
            {
                dx = 0;
                dy = 0;
                dz = 0;
                if(mode==1)
                {
                    dx = stepSize;
                }
                else if (mode == 2)
                {
                    dx = -1 * stepSize;
                }
                else if (mode == 3) {
                    dy =  stepSize;
                }
                else if (mode == 4) {
                    dy = -1 * stepSize;
                }
                else if (mode == 5) {
                    dz = stepSize;
                }
                else if (mode == 6) {
                    dz = -1 * stepSize;
                }
                mode++;
                if(mode>6)
                {
                    mode = 1;
                }
            }

            function distance2camera(camerapoint)
            {
                if (started) {
                    var i = 0;
                    var distance = 0;
                    var camx = camerapoint.x;
                    var camy = camerapoint.y;
                    var camz = camerapoint.z;
                    var n = 3;
                    for (; i < n; ++i) {
                        if (point_status[i] == 1) {
                            //Get pixel position
                            var pixelx = curr_xy[i << 1];
                            var pixely = curr_xy[(i << 1) + 1];
                            //Calculate projected position of measured point
                            var projpointx = camx + (pixelx * convx);
                            var projpointy = camy + (pixely * convy);
                            var projpointz = camz + constz;
                            //Cache Physical Known Point
                            var knownpointx = knownpoints[i].x;
                            var knownpointy = knownpoints[i].y;
                            var knownpointz = knownpoints[i].z;
                            //Do math
                            var Lx = projpointx - knownpointx;
                            var Ly = projpointy - knownpointy;
                            var Lz = projpointz - knownpointz;
                            var Wx = camx - knownpointx;
                            var Wy = camy - knownpointy;
                            var Wz = camz - knownpointz;
                            var LWx = Ly * Wz - Wy * Lz;
                            var LWy = Lz * Wx - Lx * Wz;
                            var LWz = Lx * Wy - Wx * Ly;
                            var LWabs = Math.sqrt((LWx * LWx) + (LWy * LWy) + (LWz * LWz));
                            var Labs = Math.sqrt((Lx * Lx) + (Ly * Ly) + (Lz * Lz));
                            distance += (LWabs / Labs) * (LWabs / Labs);
                        }
                    }
                    //console.log(distance);
                    return distance;
                }
                return -1;
            }

            function draw_circle(ctx, x, y) {
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.fill();
            }


            //One feature will always remain from feature-feature pruning.
            //This should then get caught in point-feature pruning.
            //If not it, will get caught in point-point pruning.



            function prune_features(x, y) {
                var l = count;
                //console.log(corners);
                for (var i = 0; i < count; ++i) {
                    if (distance(x, y, corners[i].x, corners[i].y) < featuretopoint) {
                        corners.pop(i);
                        l--;
                    }
                }
                count = l;
            }

            function prune_oflow_points(ctx) {
                var n = point_count;
                var i = 0, j = 0, k = 0;
                //console.log("points: " + point_count);
                for (; i < n; ++i) {
                    if (point_status[i] == 1) {
                        var tooclose = false;
                        for (k = i + 1; k < n; k++)
                        {
                            if(point_status[k] == 1)
                            {
                                if(distance(curr_xy[i << 1], curr_xy[(i << 1)+1], curr_xy[k << 1], curr_xy[(k << 1) +1])<pointtopoint)
                                {
                                    //console.log("pruned pointtopoint");
                                    point_status[k] = 2;

                                }
                            }
                        }

                            if (j < i) {
                                curr_xy[j << 1] = curr_xy[i << 1];
                                curr_xy[(j << 1) + 1] = curr_xy[(i << 1) + 1];
                            }
                            draw_circle(ctx, curr_xy[j << 1], curr_xy[(j << 1) + 1]);
                            ++j;
                            prune_features(curr_xy[j << 1].x, curr_xy[(j << 1) + 1].y);
                    }
                }
                point_count = j;
            }

            function distance(x1,y1,x2,y2)
            {
                return (Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)));
            }

            function render_corners(img, step) {
                var pix = (0xff << 24) | (0xff << 16) | (0xff << 8) | 0xff;

                for (var i = 0; i < count; ++i)
                {
                    for(var l=i+1; l<count; ++l)
                    {
                        if(distance(corners[i].x,corners[i].y,corners[l].x,corners[l].y)<featuretofeature)
                        {
                            //console.log("filtered: " + distance(corners[i].x, corners[i].y, corners[l].x, corners[l].y));
                            corners.pop(l);
                            l--;
                            count--;
                        }
                    }
                }
                count = l;

                for (var i = 0; i < count; ++i) {
                    var x = corners[i].x;
                    var y = corners[i].y;
                    if (point_count < maxpoints) {
                        if (ctx[off] != pix) {
                            //console.log("added point : "+x+","+y);
                            //addpoint(x, y);
                        }
                    }
                    var off = (x + y * step);
                    if (ctx2[off] == undefined) {
                        ctx2[off] = (0x00 << 24) | (0x00 << 16) | (0x00 << 8) | 0x01;
                    }
                    if (ctx2[off] <= featurepersistancetocount+1) {
                        ctx2[off] = ctx2[off] + 1;
                        ctx2[off + 1] = ctx2[off + 1] + 1;
                        ctx2[off - 1] = ctx2[off - 1] + 1;
                        ctx2[off + step] = ctx2[off + step] + 1;
                        ctx2[off -step] = ctx2[off -step] + 1;
                        //console.log("increment1: "+ctx2[off]);
                    }
                    if ((ctx2[off] > featurepersistancetocount))
                    {
                        if(point_count<maxpoints)
                        {
                            addpoint(x, y);
                            ctx2[off] = 0;
                        }
                    }

                    //console.log(ctx2[off]);
                    //if (ctx2[off] > 1000) {
                    img[off] = pix;
                    //}

                }
            }



            function relMouseCoords(event) {
                var totalOffsetX = 0, totalOffsetY = 0, canvasX = 0, canvasY = 0;
                var currentElement = this;

                do {
                    totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
                    totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
                } while (currentElement = currentElement.offsetParent)

                canvasX = event.pageX - totalOffsetX;
                canvasY = event.pageY - totalOffsetY;

                return { x: canvasX, y: canvasY }
            }
            HTMLCanvasElement.prototype.relMouseCoords = relMouseCoords;



            $(window).unload(function() {
                video.pause();
                video.src=null;
            });
        });
        </script>
    
</body></html>



































